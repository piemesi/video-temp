import React, { Component, PropTypes } from 'react';
import classNames from 'classnames';

var babelHelpers = {};

babelHelpers.classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

babelHelpers.extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

babelHelpers.inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

babelHelpers.possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

babelHelpers;

var BackgroundVideo = function (_Component) {
  babelHelpers.inherits(BackgroundVideo, _Component);

  function BackgroundVideo() {
    babelHelpers.classCallCheck(this, BackgroundVideo);
    return babelHelpers.possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  BackgroundVideo.prototype.componentWillUnmount = function componentWillUnmount() {
    var videoElement = document.getElementById(this.props.videoId);

    if (videoElement) {
      videoElement.pause();
      videoElement.src = '';
      videoElement.load();
    }
  };

  BackgroundVideo.prototype.render = function render() {
    var _classNames, _classNames2;

    var videos = this.props.videos.map(function (video, index) {
      return React.createElement('source', { key: index, src: video.src, type: video.type });
    });

    var videoProps = {
      preload: this.props.preload,
      loop: this.props.loop,
      autoPlay: this.props.autoPlay,
      poster: this.props.poster
    };

    var videoClassNames = classNames((_classNames = {
      'video-container': true
    }, _classNames[this.props.className] = !!this.props.className, _classNames));

    var videoOverlayClassNames = classNames((_classNames2 = {
      'video-overlay': true
    }, _classNames2[this.props.overlayClassName] = !!this.props.overlayClassName, _classNames2));

    var overlayElement = this.props.overlay ? React.createElement('div', { className: videoOverlayClassNames }) : null;

    return React.createElement(
      'div',
      { className: videoClassNames, onClick: this.props.onClick },
      React.createElement(
        'video',
        babelHelpers.extends({ id: this.props.videoId, className: 'video-background' }, videoProps),
        videos
      ),
      overlayElement,
      React.createElement(
        'div',
        { className: 'video-content' },
        this.props.children
      )
    );
  };

  return BackgroundVideo;
}(Component);

BackgroundVideo.propTypes = {
  videos: React.PropTypes.arrayOf(PropTypes.shape({
    src: PropTypes.string,
    type: PropTypes.string
  })),
  children: PropTypes.node,
  preload: PropTypes.bool,
  loop: PropTypes.bool,
  autoPlay: PropTypes.bool,
  className: PropTypes.string,
  overlayClassName: PropTypes.string,
  videoId: PropTypes.string,
  overlay: PropTypes.bool,
  poster: PropTypes.string,
  onClick: PropTypes.func
};
BackgroundVideo.defaultProps = {
  videos: [],
  preload: true,
  loop: false,
  autoPlay: true,
  className: '',
  overlayClassName: '',
  videoId: 'video-#{Date.now()}',
  overlay: true
};

export default BackgroundVideo;